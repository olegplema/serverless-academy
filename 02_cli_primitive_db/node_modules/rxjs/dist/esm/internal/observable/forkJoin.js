import { Observable } from 'rxjs/dist/esm/internal/Observable';
import { argsArgArrayOrObject } from 'rxjs/dist/esm/internal/util/argsArgArrayOrObject';
import { innerFrom } from 'rxjs/dist/esm/internal/observable/innerFrom';
import { popResultSelector } from 'rxjs/dist/esm/internal/util/args';
import { createOperatorSubscriber } from 'rxjs/dist/esm/internal/operators/OperatorSubscriber';
import { mapOneOrManyArgs } from 'rxjs/dist/esm/internal/util/mapOneOrManyArgs';
import { createObject } from 'rxjs/dist/esm/internal/util/createObject';
export function forkJoin(...args) {
    const resultSelector = popResultSelector(args);
    const { args: sources, keys } = argsArgArrayOrObject(args);
    const result = new Observable((subscriber) => {
        const { length } = sources;
        if (!length) {
            subscriber.complete();
            return;
        }
        const values = new Array(length);
        let remainingCompletions = length;
        let remainingEmissions = length;
        for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {
            let hasValue = false;
            innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, (value) => {
                if (!hasValue) {
                    hasValue = true;
                    remainingEmissions--;
                }
                values[sourceIndex] = value;
            }, () => remainingCompletions--, undefined, () => {
                if (!remainingCompletions || !hasValue) {
                    if (!remainingEmissions) {
                        subscriber.next(keys ? createObject(keys, values) : values);
                    }
                    subscriber.complete();
                }
            }));
        }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
//# sourceMappingURL=forkJoin.js.map